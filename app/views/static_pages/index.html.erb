<section class="todoapp">
  <header class="header">
    <h1>Maze Generator</h1>
  </header>

  <section id="theMaze">
  </section>
  <input type="submit" value="Submit" onclick="mazeDisplay(map)">
</section>

<style>
div {
  display: inline-block;
  width: 20px;
  height: 20px;
  }

.mazeRow {}
.mazeColumn   {color: blue;}
.Red {
  background-color: Red;
}
.Green {
  background-color: Green;
}
p    {color: red;}
</style>


<script>
$(function() {
  $.get("/mazes").success( function(data) {
    $.each(data, function(index, maze) {
      console.log(maze.source);
    });
    mazeCreate();
  });
});

var mazzztop;

mazeDisplay = function(theMaze) {
  // theMaze should be an array with several arrays inside of it. 
    // theMaze[x][1 ... ?] should contain a variable 1-16 that defines which direction each node, or 'Room', is facing
  var currentRow;
  mazzztop = theMaze;
  for (currentRow = 0; currentRow < theMaze.length; currentRow++) {
    var newRow = $("<div></div>").addClass("mazeRow");
    console.log("currentRow = " + currentRow + " == " + theMaze[currentRow]);
    var currentColumn;
    for (currentColumn = 0; currentColumn < theMaze[currentRow].length; currentColumn++) {
      console.log(currentRow + " x " + currentColumn + " : " + theMaze[currentRow][currentColumn])
      var newColumn = $("<div></div>");
      newColumn.addClass("mazeColumn");
      if(theMaze[currentRow][currentColumn] == true) {
        newColumn.addClass("Green").text("T");
      } else {
        newColumn.addClass("Red").text("F");
      }
      newRow.append(newColumn)
    }
    $("#theMaze").append(newRow);
  }
}

mazeCreate = function(){
  // Maze created with help from Gabriel Valfridsson's CodePen :: https://codepen.io/GabbeV/pen/viAec 
  width = 25           //Number paths fitted horisontally
  height = 25          //Number paths fitted vertically
  pathWidth = 10       //Width of the Maze Path
  wall = 2             //Width of the Walls between Paths
  outerWall = 2        //Width of the Outer most wall
  pathColor = '#222a33'//Color of the path
  wallColor = '#d24'   //Color of the walls
  // seed = Math.random()*100000|0//Seed for random numbers
  x = width/2|0        //Horisontal starting position
  y = height/2|0       //Vertical starting position
  // INIT
  offset = pathWidth/2+outerWall
  map = []
  // canvas = document.querySelector('canvas')
  // ctx = canvas.getContext('2d')
  // canvas.width = outerWall*2+width*(pathWidth+wall)-wall
  // canvas.height = outerWall*2+height*(pathWidth+wall)-wall
  // ctx.fillStyle = wallColor
  // ctx.fillRect(0,0,canvas.width,canvas.height)
  random = Math.random()*100000|0
  // ctx.strokeStyle = pathColor
  // ctx.lineCap = 'square'
  // ctx.lineWidth = pathWidth
  // ctx.beginPath()
  for(var i=0;i<height*2;i++){
    map[i] = []
    for(var j=0;j<width*2;j++){
      map[i][j] = false
    }
  }
  map[y*2][x*2] = true
  route = [[x,y]]
  // ctx.moveTo(x*(pathWidth+wall)+offset,y*(pathWidth+wall)+offset)
  loop();
};

random = function(){
  return Math.random()*100000|0
};

loop = function(){
  x = route[route.length-1][0]|0
  y = route[route.length-1][1]|0
  
    //*** changed directions to 2 to allow space for the walls
  var directions = [[1,0],[-1,0],[0,1],[0,-1]],
      alternatives = []
  
  for(var i=0;i<directions.length;i++){
    if(map[(directions[i][1]+y)*2]!=undefined&&
       map[(directions[i][1]+y)*2][(directions[i][0]+x)*2]===false){
      alternatives.push(directions[i])
    }
  }
  
  if(alternatives.length===0){
    route.pop()
    if(route.length>0){
      // ctx.moveTo(route[route.length-1][0]*(pathWidth+wall)+offset,route[route.length-1][1]*(pathWidth+wall)+offset)
      timer = setTimeout(loop,1)
    }
    return;
  }
  direction = alternatives[Math.random()*alternatives.length|0]
  route.push([direction[0]+x,direction[1]+y])
  // ctx.lineTo((direction[0]+x)*(pathWidth+wall)+offset,(direction[1]+y)*(pathWidth+wall)+offset)
  map[(direction[1]+y)*2][(direction[0]+x)*2] = true
  map[direction[1]+y*2][direction[0]+x*2] = true
  // ctx.stroke()
  timer = setTimeout(loop,1)
};
</script>